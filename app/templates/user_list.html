{% extends 'base.html' %}
{% block content %}

<div class="card p-3">

    <h5 class="mb-3"><i class="fa-solid fa-users me-2"></i>Your Chats</h5>

    <div class="list-group list-group-flush" id="users-list">
        {% for u in users %}
        <a href="{% url 'chat' u.id %}"
            class="list-group-item list-group-item-action d-flex justify-content-between align-items-center"
            data-user-id="{{ u.id }}">

            <div class="d-flex align-items-center gap-3">
                <!-- <div class="avatar" >{{ u.username|first|upper }}</div> -->
                <div>
                    {{ u.username }}
                    <span class="unread-count badge bg-danger" data-user-unread="{{ u.id }}"
                        style="display: none; margin-left: 8px;">0</span>
                </div>
            </div>

            <span class="user-status" data-status-user-id="{{ u.id }}">
                {% if u.is_online %}
                <i class="fa-solid fa-circle text-success status-dot"></i> Online
                {% else %}
                <i class="fa-solid fa-circle text-danger status-dot"></i> Offline
                {% endif %}
            </span>

        </a>
        {% endfor %}
    </div>

</div>

<script>
    let presenceSocket;
    let unreadCountRefreshInterval;
    let presenceHeartbeatInterval;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY = 3000; // 3 seconds
    let shouldReconnect = true;

    function initPresenceSocket() {
        presenceSocket = new WebSocket(
            "ws://" + window.location.host + "/ws/presence/"
        );

        presenceSocket.onopen = function (e) {
            console.log("Presence socket connected");
            reconnectAttempts = 0;
            loadUnreadCounts();

            // Refresh unread counts every 3 seconds
            if (unreadCountRefreshInterval) {
                clearInterval(unreadCountRefreshInterval);
            }
            unreadCountRefreshInterval = setInterval(loadUnreadCounts, 3000);

            // Send heartbeat every 30 seconds to keep connection alive
            if (presenceHeartbeatInterval) {
                clearInterval(presenceHeartbeatInterval);
            }
            presenceHeartbeatInterval = setInterval(() => {
                if (presenceSocket && presenceSocket.readyState === WebSocket.OPEN) {
                    presenceSocket.send(JSON.stringify({ type: "ping" }));
                }
            }, 30000);
        };

        presenceSocket.onmessage = function (e) {
            try {
                const data = JSON.parse(e.data);

                if (data.type === "presence") {
                    console.log("Presence update received:", data);
                    const statusElement = document.querySelector(`[data-status-user-id="${data.user_id}"]`);

                    if (statusElement) {
                        if (data.is_online) {
                            statusElement.innerHTML = '<i class="fa-solid fa-circle text-success status-dot"></i> Online';
                        } else {
                            statusElement.innerHTML = '<i class="fa-solid fa-circle text-danger status-dot"></i> Offline';
                        }
                    } else {
                        console.warn("Status element not found for user:", data.user_id);
                    }
                }
            } catch (error) {
                console.error("Error parsing presence message:", error);
            }
        };

        presenceSocket.onerror = function (error) {
            console.error("Presence socket error:", error);
        };

        presenceSocket.onclose = function (e) {
            console.log("Presence socket closed. Code:", e.code, "Reason:", e.reason);
            
            if (unreadCountRefreshInterval) {
                clearInterval(unreadCountRefreshInterval);
            }
            if (presenceHeartbeatInterval) {
                clearInterval(presenceHeartbeatInterval);
            }

            // Attempt to reconnect if we're still on this page
            if (shouldReconnect && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                console.log(`Attempting to reconnect (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                setTimeout(initPresenceSocket, RECONNECT_DELAY);
            }
        };
    }

    // Load unread counts
    function loadUnreadCounts() {
        fetch("/api/unread-counts/")
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log("Unread counts:", data);
                Object.entries(data).forEach(([userId, count]) => {
                    updateUnreadBadge(parseInt(userId), count);
                });
            })
            .catch(error => console.error("Error loading unread counts:", error));
    }

    function updateUnreadBadge(userId, count) {
        const badge = document.querySelector(`[data-user-unread="${userId}"]`);
        if (badge) {
            if (count > 0) {
                badge.textContent = count;
                badge.style.display = "inline-block";
            } else {
                badge.style.display = "none";
            }
        }
    }

    // Initialize presence socket
    initPresenceSocket();

    // Fallback: Load unread counts on page load if WebSocket doesn't connect
    window.addEventListener('load', () => {
        setTimeout(loadUnreadCounts, 1000);
    });

    // Close presence socket when user leaves this page (navigate away, close tab, etc)
    window.addEventListener('beforeunload', () => {
        shouldReconnect = false;
        if (presenceSocket && presenceSocket.readyState === WebSocket.OPEN) {
            presenceSocket.close();
        }
        if (unreadCountRefreshInterval) {
            clearInterval(unreadCountRefreshInterval);
        }
        if (presenceHeartbeatInterval) {
            clearInterval(presenceHeartbeatInterval);
        }
    });

    // Also handle page hide (when switching tabs, etc)
    window.addEventListener('pagehide', () => {
        shouldReconnect = false;
        if (presenceSocket && presenceSocket.readyState === WebSocket.OPEN) {
            presenceSocket.close();
        }
    });

    // Handle page visibility changes to reconnect if needed
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden && presenceSocket && presenceSocket.readyState === WebSocket.CLOSED) {
            console.log("Page became visible, reconnecting...");
            shouldReconnect = true;
            reconnectAttempts = 0;
            initPresenceSocket();
        }
    });
</script>

{% endblock %}